"""
ä»»åŠ¡åˆ†ç±»ä¸å¸è½½å†³ç­–æ¡†æ?- å¯¹åº”è®ºæ–‡ç¬?èŠ‚å’Œç¬?èŠ?
å®ç°åŸºäºå»¶è¿Ÿå®¹å¿åº¦çš„ä»»åŠ¡åˆ†ç±»å’Œå¤„ç†æ¨¡å¼è¯„ä¼?
"""
import numpy as np
import math
from typing import Dict, List, Tuple, Optional, Set, Union
from dataclasses import dataclass
from enum import Enum

from models.data_structures import Task, TaskType, Position, NodeType
from config import config


class ProcessingMode(Enum):
    """å¤„ç†æ¨¡å¼æšä¸¾ - å¯¹åº”è®ºæ–‡ç¬?èŠ?""
    LOCAL_COMPUTING = "local"           # æ¨¡å¼ä¸€ï¼šæœ¬åœ°è®¡ç®?
    RSU_OFFLOAD_CACHE_HIT = "rsu_hit"   # æ¨¡å¼äºŒï¼šRSUå¸è½½(ç¼“å­˜å‘½ä¸­)
    RSU_OFFLOAD_NO_CACHE = "rsu_miss"   # æ¨¡å¼äºŒï¼šRSUå¸è½½(ç¼“å­˜æœªå‘½ä¸?
    RSU_MIGRATION = "rsu_migration"     # æ¨¡å¼ä¸‰ï¼šRSUé—´è¿ç§?
    UAV_OFFLOAD = "uav_offload"         # æ¨¡å¼å››ï¼šUAVå¸è½½


@dataclass
class ProcessingOption:
    """å¤„ç†é€‰é¡¹æ•°æ®ç»“æ„"""
    mode: ProcessingMode
    target_node_id: str
    predicted_delay: float
    energy_cost: float
    success_probability: float
    migration_source: Optional[str] = None  # è¿ç§»æºèŠ‚ç‚?(ä»…è¿ç§»æ¨¡å¼?
    cache_hit: bool = False  # æ˜¯å¦ç¼“å­˜å‘½ä¸­
    
    @property
    def weighted_cost(self) -> float:
        """è®¡ç®—åŠ æƒæˆæœ¬"""
        # å½’ä¸€åŒ–å› å­?- åŸºäºå®é™…æ•°æ®èŒƒå›´è°ƒæ•´
        delay_norm = 0.15  # ç§?(åŸºäºå¹³å‡æ—¶å»¶0.08ç§?
        energy_norm = 250.0  # ç„¦è€?(åŸºäºå¹³å‡èƒ½è€?00Wå·¦å³)
        
        # æƒé‡ (å¯é…ç½? - è¿›ä¸€æ­¥å¢åŠ èƒ½è€—æƒé‡ä»¥ä¿ƒè¿›å¸è½½
        w_delay = 0.15  # è¿›ä¸€æ­¥é™ä½æ—¶å»¶æƒé‡?
        w_energy = 0.7  # è¿›ä¸€æ­¥å¢åŠ èƒ½è€—æƒé‡?
        w_reliability = 0.15  # è¿›ä¸€æ­¥é™ä½å¯é æ€§æƒé‡?
        
        normalized_delay = self.predicted_delay / delay_norm
        normalized_energy = self.energy_cost / energy_norm
        reliability_penalty = 1.0 - self.success_probability
        
        return (w_delay * normalized_delay + 
                w_energy * normalized_energy + 
                w_reliability * reliability_penalty)


class TaskClassifier:
    """
    ä»»åŠ¡åˆ†ç±»å™?- å¯¹åº”è®ºæ–‡ç¬?.1èŠ‚ä»»åŠ¡åˆ†ç±»æ¡†æ?
    æ ¹æ®å»¶è¿Ÿå®¹å¿åº¦å¯¹ä»»åŠ¡è¿›è¡Œå››çº§åˆ†ç±»
    """
    
    def __init__(self):
        # å»¶è¿Ÿé˜ˆå€?- å¯¹åº”è®ºæ–‡Ï„â‚? Ï„â‚? Ï„â‚?
        self.threshold_1 = config.task.delay_threshold_1  # æåº¦å»¶è¿Ÿæ•æ„Ÿ
        self.threshold_2 = config.task.delay_threshold_2  # å»¶è¿Ÿæ•æ„Ÿ  
        self.threshold_3 = config.task.delay_threshold_3  # ä¸­åº¦å»¶è¿Ÿå®¹å¿
        
        # ä»»åŠ¡ç±»å‹ç»Ÿè®¡
        self.classification_stats: Dict[TaskType, int] = {
            TaskType.EXTREMELY_DELAY_SENSITIVE: 0,
            TaskType.DELAY_SENSITIVE: 0,
            TaskType.MODERATELY_DELAY_TOLERANT: 0,
            TaskType.DELAY_TOLERANT: 0
        }
    
    def classify_task(self, task: Task) -> TaskType:
        """
        ä»»åŠ¡åˆ†ç±» - å¯¹åº”è®ºæ–‡ç¬?.1èŠ?
        æ ¹æ®T_max,jä¸é˜ˆå€¼Ï„â‚,Ï„â‚?Ï„â‚ƒçš„æ¯”è¾ƒç¡®å®šç±»åˆ«
        """
        max_delay = task.max_delay_slots
        
        if max_delay <= self.threshold_1:
            task_type = TaskType.EXTREMELY_DELAY_SENSITIVE
        elif max_delay <= self.threshold_2:
            task_type = TaskType.DELAY_SENSITIVE
        elif max_delay <= self.threshold_3:
            task_type = TaskType.MODERATELY_DELAY_TOLERANT
        else:
            task_type = TaskType.DELAY_TOLERANT
        
        # æ›´æ–°ä»»åŠ¡ç±»å‹å¹¶ç»Ÿè®?
        task.task_type = task_type
        self.classification_stats[task_type] += 1
        
        return task_type
    
    def get_candidate_nodes(self, task: Task, all_nodes: Dict[str, Position]) -> List[str]:
        """
        è·å–å€™é€‰èŠ‚ç‚¹é›†å?- å¯¹åº”è®ºæ–‡ç¬?.2èŠ‚å¸è½½å¯¼å‘ç­–ç•?
        
        Args:
            task: å¾…å¤„ç†ä»»åŠ?
            all_nodes: æ‰€æœ‰èŠ‚ç‚¹ä½ç½®ä¿¡æ?{node_id: Position}
            
        Returns:
            å€™é€‰èŠ‚ç‚¹IDåˆ—è¡¨
        """
        task_type = task.task_type
        source_vehicle_id = task.source_vehicle_id
        
        if task_type == TaskType.EXTREMELY_DELAY_SENSITIVE:
            # ç±»åˆ«1: ä»…æœ¬åœ°å¤„ç?- N_j^cand = {v_j}
            return [source_vehicle_id]
        
        elif task_type == TaskType.DELAY_SENSITIVE:
            # ç±»åˆ«2: æœ¬åœ° + è¿‘è·ç¦»ä½å»¶è¿ŸRSU + UAV - æ‰©å±•ä»¥åŒ…å«UAV
            candidates = [source_vehicle_id]
            
            # æ·»åŠ è·ç¦»æœ€è¿‘çš„å‡ ä¸ªRSU
            nearby_rsus = self._get_nearby_rsus(source_vehicle_id, all_nodes, max_distance=800.0, max_count=3)
            candidates.extend(nearby_rsus)
            
            # æ·»åŠ UAVä»¥å¢åŠ å¸è½½é€‰æ‹©
            capable_uavs = self._get_capable_uavs(source_vehicle_id, all_nodes, max_distance=500.0)
            candidates.extend(capable_uavs)
            
            return candidates
        
        elif task_type == TaskType.MODERATELY_DELAY_TOLERANT:
            # ç±»åˆ«3: æœ¬åœ° + å¯è¾¾RSU + è¿‘è·ç¦»UAV - N_j^cand âŠ?{v_j} âˆ?R_reachable âˆ?U_capable,nearby
            candidates = [source_vehicle_id]
            
            # æ·»åŠ å¯è¾¾çš„RSU
            reachable_rsus = self._get_reachable_rsus(source_vehicle_id, all_nodes, max_distance=800.0)
            candidates.extend(reachable_rsus)
            
            # æ·»åŠ è¿‘è·ç¦»æœ‰èƒ½åŠ›çš„UAV
            capable_uavs = self._get_capable_uavs(source_vehicle_id, all_nodes, max_distance=600.0)
            candidates.extend(capable_uavs)
            
            return candidates
        
        else:  # DELAY_TOLERANT
            # ç±»åˆ«4: æ‰€æœ‰èŠ‚ç‚?- N_j^cand = N
            return list(all_nodes.keys())
    
    def _get_nearby_rsus(self, vehicle_id: str, all_nodes: Dict[str, Position], 
                        max_distance: float, max_count: int) -> List[str]:
        """è·å–é™„è¿‘çš„RSU"""
        if vehicle_id not in all_nodes:
            return []
        
        vehicle_pos = all_nodes[vehicle_id]
        rsu_distances = []
        
        for node_id, position in all_nodes.items():
            if node_id.startswith("rsu_"):
                distance = vehicle_pos.distance_to(position)
                if distance <= max_distance:
                    rsu_distances.append((distance, node_id))
        
        # æŒ‰è·ç¦»æ’åºå¹¶è¿”å›æœ€è¿‘çš„å‡ ä¸ª
        rsu_distances.sort(key=lambda x: x[0])
        return [node_id for _, node_id in rsu_distances[:max_count]]
    
    def _get_reachable_rsus(self, vehicle_id: str, all_nodes: Dict[str, Position], 
                           max_distance: float) -> List[str]:
        """è·å–å¯è¾¾çš„RSU"""
        if vehicle_id not in all_nodes:
            return []
        
        vehicle_pos = all_nodes[vehicle_id]
        reachable_rsus = []
        
        for node_id, position in all_nodes.items():
            if node_id.startswith("rsu_"):
                distance = vehicle_pos.distance_to(position)
                if distance <= max_distance:
                    reachable_rsus.append(node_id)
        
        return reachable_rsus
    
    def _get_capable_uavs(self, vehicle_id: str, all_nodes: Dict[str, Position], 
                         max_distance: float) -> List[str]:
        """è·å–æœ‰èƒ½åŠ›çš„UAV"""
        if vehicle_id not in all_nodes:
            return []
        
        vehicle_pos = all_nodes[vehicle_id]
        capable_uavs = []
        
        for node_id, position in all_nodes.items():
            if node_id.startswith("uav_"):
                distance = vehicle_pos.distance_2d_to(position)  # 2Dè·ç¦»
                if distance <= max_distance:
                    capable_uavs.append(node_id)
        
        return capable_uavs
    
    def get_classification_distribution(self) -> Dict[TaskType, float]:
        """è·å–ä»»åŠ¡åˆ†ç±»åˆ†å¸ƒ"""
        total = sum(self.classification_stats.values())
        if total == 0:
            return {task_type: 0.0 for task_type in TaskType}
        
        return {task_type: count / total for task_type, count in self.classification_stats.items()}


class ProcessingModeEvaluator:
    """
    å¤„ç†æ¨¡å¼è¯„ä¼°å™?- å¯¹åº”è®ºæ–‡ç¬?èŠ‚å¤„ç†æ¨¡å¼è¯„ä¼°æ¡†æ?
    åœ¨å€™é€‰é›†å†…è¯„ä¼°ä¸åŒå¤„ç†æ¨¡å¼çš„æ€§èƒ½
    """
    
    def __init__(self):
        # è¯„ä¼°å‚æ•° - ä¼˜åŒ–é€šä¿¡å¼€é”€
        self.communication_overhead = 0.0002  # é€šä¿¡å¼€é”€ (ç§? - é™ä½å¼€é”€
        self.cache_response_delay = 0.0001   # ç¼“å­˜å“åº”æ—¶å»¶ (ç§? - é™ä½ç¼“å­˜æ—¶å»¶
        
        # æˆæœ¬æƒé‡
        self.delay_weight = 0.6
        self.energy_weight = 0.3
        self.reliability_weight = 0.1
    
    def evaluate_all_modes(self, task: Task, candidate_nodes: List[str], 
                          node_states: Dict, node_positions: Dict[str, Position],
                          cache_states: Optional[Dict] = None) -> List[ProcessingOption]:
        """
        è¯„ä¼°æ‰€æœ‰å¯è¡Œçš„å¤„ç†æ¨¡å¼
        
        Args:
            task: å¾…å¤„ç†ä»»åŠ?
            candidate_nodes: å€™é€‰èŠ‚ç‚¹åˆ—è¡?
            node_states: èŠ‚ç‚¹çŠ¶æ€ä¿¡æ?
            node_positions: èŠ‚ç‚¹ä½ç½®ä¿¡æ¯
            cache_states: ç¼“å­˜çŠ¶æ€ä¿¡æ?(å¯é€?
            
        Returns:
            å¤„ç†é€‰é¡¹åˆ—è¡¨
        """
        options = []
        
        for node_id in candidate_nodes:
            if node_id.startswith("vehicle_"):
                # æ¨¡å¼ä¸€ï¼šæœ¬åœ°è®¡ç®?
                option = self._evaluate_local_computing(task, node_id, node_states)
                if option:
                    options.append(option)
            
            elif node_id.startswith("rsu_"):
                # æ¨¡å¼äºŒï¼šRSUå¸è½½ (æ£€æŸ¥ç¼“å­˜å‘½ä¸?
                cache_options = self._evaluate_rsu_offload(task, node_id, node_states, 
                                                         node_positions, cache_states or {})
                options.extend(cache_options)
                
                # æ¨¡å¼ä¸‰ï¼šRSUé—´è¿ç§?(å¦‚æœé€‚ç”¨)
                migration_options = self._evaluate_rsu_migration(task, node_id, node_states, 
                                                               node_positions)
                options.extend(migration_options)
            
            elif node_id.startswith("uav_"):
                # æ¨¡å¼å››ï¼šUAVå¸è½½
                option = self._evaluate_uav_offload(task, node_id, node_states, node_positions)
                if option:
                    options.append(option)
        
        return options
    
    def _evaluate_local_computing(self, task: Task, vehicle_id: str, 
                                 node_states: Dict) -> Optional[ProcessingOption]:
        """è¯„ä¼°æœ¬åœ°è®¡ç®—æ¨¡å¼ - å¯¹åº”è®ºæ–‡ç¬?.1èŠ?""
        if vehicle_id not in node_states:
            return None
        
        vehicle_state = node_states[vehicle_id]
        
        # è®¡ç®—å¤„ç†æ—¶å»¶ - è®ºæ–‡å¼?6)
        parallel_efficiency = config.compute.parallel_efficiency
        processing_delay = task.compute_cycles / (vehicle_state.cpu_frequency * parallel_efficiency)
        
        # é¢„æµ‹ç­‰å¾…æ—¶å»¶ (ç®€åŒ?
        waiting_delay = self._estimate_waiting_time(vehicle_state)
        
        total_delay = processing_delay + waiting_delay
        
        # è®¡ç®—èƒ½è€?- ä½¿ç”¨çœŸå®çš„æœ¬åœ°å¤„ç†èƒ½è€?
        base_energy = self._calculate_local_energy(task, vehicle_state)
        energy_cost = base_energy  # ä½¿ç”¨çœŸå®èƒ½è€—ï¼Œä¸æ–½åŠ æƒ©ç½?
        
        # æˆåŠŸæ¦‚ç‡ (æé«˜æœ¬åœ°å¤„ç†å¸å¼•åŠ›ä»¥å¹³è¡¡è´Ÿè½½)
        if total_delay <= task.max_delay_slots * config.network.time_slot_duration * 0.8:
            success_prob = 0.90  # é«˜æˆåŠŸç‡ï¼Œåœ¨80%æ—¶é—´å†…å®Œæˆ?
        elif total_delay <= task.max_delay_slots * config.network.time_slot_duration:
            success_prob = 0.75  # ä¸­ç­‰æˆåŠŸç‡ï¼Œåœ¨æˆªæ­¢æ—¶é—´å†…å®Œæˆ
        else:
            success_prob = 0.20  # ä½æˆåŠŸç‡ï¼Œè¶…è¿‡æˆªæ­¢æ—¶é—?
        
        return ProcessingOption(
            mode=ProcessingMode.LOCAL_COMPUTING,
            target_node_id=vehicle_id,
            predicted_delay=total_delay,
            energy_cost=energy_cost,
            success_probability=success_prob
        )
    
    def _evaluate_rsu_offload(self, task: Task, rsu_id: str, node_states: Dict,
                             node_positions: Dict[str, Position], 
                             cache_states: Dict) -> List[ProcessingOption]:
        """è¯„ä¼°RSUå¸è½½æ¨¡å¼ - å¯¹åº”è®ºæ–‡ç¬?.2èŠ?""
        options = []
        
        if rsu_id not in node_states or task.source_vehicle_id not in node_positions:
            return options
        
        rsu_state = node_states[rsu_id]
        vehicle_pos = node_positions[task.source_vehicle_id]
        rsu_pos = node_positions[rsu_id]
        
        # è®¡ç®—é€šä¿¡æ—¶å»¶
        distance = vehicle_pos.distance_to(rsu_pos)
        upload_delay = self._calculate_transmission_delay(task.data_size, distance, "upload")
        download_delay = self._calculate_transmission_delay(task.result_size, distance, "download")
        
        # æ£€æŸ¥ç¼“å­˜å‘½ä¸?
        cache_hit = self._check_cache_hit(task, rsu_id, cache_states)
        
        if cache_hit:
            # ç¼“å­˜å‘½ä¸­æƒ…å†µ - ä½¿ç”¨çœŸå®çš„ç¼“å­˜å‘½ä¸­èƒ½è€?
            total_delay = self.communication_overhead + self.cache_response_delay + download_delay
            energy_cost = self._calculate_transmission_energy(task.result_size, download_delay)  # ä½¿ç”¨çœŸå®èƒ½è€?
            success_prob = 0.80
            
            options.append(ProcessingOption(
                mode=ProcessingMode.RSU_OFFLOAD_CACHE_HIT,
                target_node_id=rsu_id,
                predicted_delay=total_delay,
                energy_cost=energy_cost,
                success_probability=success_prob,
                cache_hit=True
            ))
        else:
            # ç¼“å­˜æœªå‘½ä¸­æƒ…å†?
            processing_delay = task.compute_cycles / rsu_state.cpu_frequency
            waiting_delay = self._estimate_waiting_time(rsu_state)
            
            total_delay = upload_delay + waiting_delay + processing_delay + download_delay
            
            # è®¡ç®—æ€»èƒ½è€?- ä½¿ç”¨çœŸå®çš„RSUå¸è½½èƒ½è€?
            upload_energy = self._calculate_transmission_energy(task.data_size, upload_delay)
            download_energy = self._calculate_transmission_energy(task.result_size, download_delay)
            energy_cost = upload_energy + download_energy  # ä½¿ç”¨çœŸå®ä¼ è¾“èƒ½è€?
            
            # æˆåŠŸæ¦‚ç‡ (RSUå¸è½½æˆåŠŸç?
            if total_delay <= task.max_delay_slots * config.network.time_slot_duration * 0.9:
                success_prob = 0.85  # RSUå¤„ç†èƒ½åŠ›å¼ºï¼Œé«˜æˆåŠŸç‡
            elif total_delay <= task.max_delay_slots * config.network.time_slot_duration:
                success_prob = 0.70  # ä¸­ç­‰æˆåŠŸç?
            else:
                success_prob = 0.30  # ä½æˆåŠŸç‡
            
            options.append(ProcessingOption(
                mode=ProcessingMode.RSU_OFFLOAD_NO_CACHE,
                target_node_id=rsu_id,
                predicted_delay=total_delay,
                energy_cost=energy_cost,
                success_probability=success_prob,
                cache_hit=False
            ))
        
        return options
    
    def _evaluate_rsu_migration(self, task: Task, target_rsu_id: str, node_states: Dict,
                               node_positions: Dict[str, Position]) -> List[ProcessingOption]:
        """è¯„ä¼°RSUé—´è¿ç§»æ¨¡å¼?- å¯¹åº”è®ºæ–‡ç¬?.3èŠ?""
        options = []
        
        # å¯»æ‰¾å¯èƒ½çš„æºRSU (å½“å‰è¿‡è½½çš„RSU)
        for source_rsu_id, state in node_states.items():
            if (source_rsu_id.startswith("rsu_") and 
                source_rsu_id != target_rsu_id and 
                state.load_factor > config.migration.rsu_overload_threshold):
                
                # è®¡ç®—è¿ç§»æˆæœ¬å’Œæ—¶å»?
                migration_delay = self._calculate_migration_delay(task, source_rsu_id, target_rsu_id, 
                                                                node_positions)
                
                # ç›®æ ‡RSUå¤„ç†æ—¶å»¶
                target_state = node_states.get(target_rsu_id)
                if target_state:
                    processing_delay = task.compute_cycles / target_state.cpu_frequency
                    waiting_delay = self._estimate_waiting_time(target_state)
                    
                    total_delay = migration_delay + waiting_delay + processing_delay
                    
                    # è¿ç§»èƒ½è€?(ç®€åŒ?
                    energy_cost = self._calculate_migration_energy(task, source_rsu_id, target_rsu_id)
                    
                    # æˆåŠŸæ¦‚ç‡ (è€ƒè™‘è¿ç§»é£é™©)
                    success_prob = 0.85 if total_delay <= task.max_delay_slots * config.network.time_slot_duration else 0.2
                    
                    options.append(ProcessingOption(
                        mode=ProcessingMode.RSU_MIGRATION,
                        target_node_id=target_rsu_id,
                        predicted_delay=total_delay,
                        energy_cost=energy_cost,
                        success_probability=success_prob,
                        migration_source=source_rsu_id
                    ))
        
        return options
    
    def _evaluate_uav_offload(self, task: Task, uav_id: str, node_states: Dict,
                             node_positions: Dict[str, Position]) -> Optional[ProcessingOption]:
        """è¯„ä¼°UAVå¸è½½æ¨¡å¼ - å¯¹åº”è®ºæ–‡ç¬?.4èŠ?""
        if uav_id not in node_states or task.source_vehicle_id not in node_positions:
            return None
        
        uav_state = node_states[uav_id]
        vehicle_pos = node_positions[task.source_vehicle_id]
        uav_pos = node_positions[uav_id]
        
        # æ£€æŸ¥UAVæ˜¯å¦å¯ç”¨ (ç”µæ± ã€è´Ÿè½½ç­‰)
        if (hasattr(uav_state, 'battery_level') and 
            uav_state.battery_level < config.migration.uav_min_battery):
            return None
        
        # è®¡ç®—é€šä¿¡æ—¶å»¶
        distance = vehicle_pos.distance_to(uav_pos)
        upload_delay = self._calculate_transmission_delay(task.data_size, distance, "upload")
        download_delay = self._calculate_transmission_delay(task.result_size, distance, "download")
        
        # è®¡ç®—å¤„ç†æ—¶å»¶ - è€ƒè™‘ç”µæ± å¯¹æ€§èƒ½çš„å½±å“?
        battery_factor = getattr(uav_state, 'battery_level', 1.0)
        effective_freq = uav_state.cpu_frequency * max(0.5, battery_factor)
        processing_delay = task.compute_cycles / effective_freq
        
        # é¢„æµ‹ç­‰å¾…æ—¶å»¶
        waiting_delay = self._estimate_waiting_time(uav_state)
        
        total_delay = upload_delay + waiting_delay + processing_delay + download_delay
        
        # è®¡ç®—èƒ½è€?- åˆç†çš„UAVèƒ½è€—è®¡ç®?
        comm_energy = self._calculate_transmission_energy(task.data_size + task.result_size, 
                                                        upload_delay + download_delay)
        compute_energy = config.compute.uav_kappa3 * (uav_state.cpu_frequency ** 2) * processing_delay
        energy_cost = comm_energy + compute_energy  # ä½¿ç”¨çœŸå®èƒ½è€?
        
        # æˆåŠŸæ¦‚ç‡ (UAVå¸è½½æˆåŠŸç‡ï¼Œè€ƒè™‘ç”µæ± å’Œè·ç¦»å› ç´?
        if total_delay <= task.max_delay_slots * config.network.time_slot_duration * 0.8:
            success_prob = 0.80  # UAVçµæ´»æ€§é«˜ä½†å—ç”µæ± é™åˆ¶
        elif total_delay <= task.max_delay_slots * config.network.time_slot_duration:
            success_prob = 0.65  # ä¸­ç­‰æˆåŠŸç?
        else:
            success_prob = 0.25  # ä½æˆåŠŸç‡
        
        return ProcessingOption(
            mode=ProcessingMode.UAV_OFFLOAD,
            target_node_id=uav_id,
            predicted_delay=total_delay,
            energy_cost=energy_cost,
            success_probability=success_prob
        )
    
    def _check_cache_hit(self, task: Task, rsu_id: str, cache_states: Dict) -> bool:
        """æ£€æŸ¥ç¼“å­˜å‘½ä¸?""
        if not cache_states or rsu_id not in cache_states:
            return False
        
        # ç®€åŒ–çš„ç¼“å­˜å‘½ä¸­æ£€æµ?
        task_signature = f"{task.task_type.value}_{int(task.data_size)}_{int(task.compute_cycles)}"
        return task_signature in cache_states.get(rsu_id, {})
    
    def _calculate_transmission_delay(self, data_size: float, distance: float, direction: str) -> float:
        """è®¡ç®—ä¼ è¾“æ—¶å»¶"""
        # ä¼˜åŒ–çš„ä¼ è¾“æ—¶å»¶æ¨¡å?- æå‡åŸºç¡€é€Ÿç‡
        base_rate = 50e6  # 50 MbpsåŸºç¡€é€Ÿç‡ (5Gç½‘ç»œ)
        
        # è·ç¦»è¡°å‡ - å‡å°‘è¡°å‡å½±å“
        path_loss_factor = 1.0 + (distance / 2000.0) ** 1.5  # é™ä½è¡°å‡ç³»æ•°
        effective_rate = base_rate / path_loss_factor
        
        transmission_delay = data_size / effective_rate
        propagation_delay = distance / 3e8  # å…‰é€Ÿä¼ æ’?
        
        return transmission_delay + propagation_delay + self.communication_overhead
    
    def _calculate_transmission_energy(self, data_size: float, transmission_time: float) -> float:
        """è®¡ç®—ä¼ è¾“èƒ½è€?""
        tx_power = config.communication.vehicle_tx_power
        circuit_power = config.communication.circuit_power
        
        return (tx_power + circuit_power) * transmission_time
    
    def _calculate_local_energy(self, task: Task, vehicle_state) -> float:
        """è®¡ç®—æœ¬åœ°å¤„ç†èƒ½è€?""
        # å¤„ç†æ—¶é—´
        processing_time = task.compute_cycles / (vehicle_state.cpu_frequency * config.compute.parallel_efficiency)
        
        # åŠ¨æ€åŠŸç?- è®ºæ–‡å¼?7)
        utilization = min(1.0, processing_time / config.network.time_slot_duration)
        dynamic_power = (config.compute.vehicle_kappa1 * (vehicle_state.cpu_frequency ** 3) +
                        config.compute.vehicle_kappa2 * (vehicle_state.cpu_frequency ** 2) * utilization +
                        config.compute.vehicle_static_power)
        
        return dynamic_power * processing_time
    
    def _calculate_migration_delay(self, task: Task, source_rsu: str, target_rsu: str,
                                  node_positions: Dict[str, Position]) -> float:
        """è®¡ç®—è¿ç§»æ—¶å»¶"""
        if source_rsu not in node_positions or target_rsu not in node_positions:
            return float('inf')
        
        source_pos = node_positions[source_rsu]
        target_pos = node_positions[target_rsu]
        distance = source_pos.distance_to(target_pos)
        
        # è¿ç§»ä¼ è¾“æ—¶å»¶
        migration_rate = config.migration.migration_bandwidth
        return task.data_size / migration_rate + distance / 3e8
    
    def _calculate_migration_energy(self, task: Task, source_rsu: str, target_rsu: str) -> float:
        """è®¡ç®—è¿ç§»èƒ½è€?""
        # ç®€åŒ–çš„è¿ç§»èƒ½è€—æ¨¡å?
        tx_power = config.communication.rsu_tx_power
        migration_time = task.data_size / config.migration.migration_bandwidth
        
        return tx_power * migration_time
    
    def _estimate_waiting_time(self, node_state) -> float:
        """ä¼°ç®—ç­‰å¾…æ—¶é—´"""
        # åŸºäºå½“å‰è´Ÿè½½çš„ç®€åŒ–ç­‰å¾…æ—¶é—´ä¼°ç®?
        if hasattr(node_state, 'load_factor'):
            if node_state.load_factor >= 1.0:
                return float('inf')
            else:
                # ç®€åŒ–çš„M/M/1å…¬å¼: W = Ï/(Î¼(1-Ï))
                base_service_time = 0.1  # åŸºç¡€æœåŠ¡æ—¶é—´
                return (node_state.load_factor * base_service_time) / (1 - node_state.load_factor)
        else:
            return 0.01  # é»˜è®¤å¾ˆå°çš„ç­‰å¾…æ—¶é—?
    
    def select_best_option(self, options: List[ProcessingOption]) -> Optional[ProcessingOption]:
        """
        é€‰æ‹©æœ€ä½³å¤„ç†é€‰é¡¹
        åŸºäºåŠ æƒæˆæœ¬å‡½æ•°
        """
        if not options:
            return None
        
        # è¿‡æ»¤æ‰ä¸å¯è¡Œçš„é€‰é¡¹
        feasible_options = [opt for opt in options if opt.success_probability > 0.1]
        
        if not feasible_options:
            return None
        
        # é€‰æ‹©åŠ æƒæˆæœ¬æœ€å°çš„é€‰é¡¹
        best_option = min(feasible_options, key=lambda x: x.weighted_cost)
        
        return best_option


class OffloadingDecisionMaker:
    """
    å¸è½½å†³ç­–åˆ¶å®šå™?- æ•´åˆåˆ†ç±»å’Œè¯„ä¼?
    å¯¹åº”è®ºæ–‡ç¬?-4èŠ‚çš„å®Œæ•´å†³ç­–æµç¨‹
    """
    
    def __init__(self):
        self.classifier = TaskClassifier()
        self.evaluator = ProcessingModeEvaluator()
        
        # å†³ç­–ç»Ÿè®¡
        self.decision_stats: Dict[ProcessingMode, int] = {mode: 0 for mode in ProcessingMode}
        self.total_decisions = 0
    
    def make_offloading_decision(self, task: Task, node_states: Dict, 
                               node_positions: Dict[str, Position],
                               cache_states: Optional[Dict] = None) -> Optional[ProcessingOption]:
        """
        åˆ¶å®šå¸è½½å†³ç­– - å®Œæ•´çš„å†³ç­–æµç¨?
        
        Args:
            task: å¾…å¤„ç†ä»»åŠ?
            node_states: æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€?
            node_positions: æ‰€æœ‰èŠ‚ç‚¹ä½ç½?
            cache_states: ç¼“å­˜çŠ¶æ€?(å¯é€?
            
        Returns:
            æœ€ä½³å¤„ç†é€‰é¡¹
        """
        # 1. ä»»åŠ¡åˆ†ç±» - è®ºæ–‡ç¬?.1èŠ?
        task_type = self.classifier.classify_task(task)
        
        # 2. ç¡®å®šå€™é€‰èŠ‚ç‚¹é›†å?- è®ºæ–‡ç¬?.2èŠ?
        candidate_nodes = self.classifier.get_candidate_nodes(task, node_positions)
        
        # 3. è¯„ä¼°æ‰€æœ‰å¤„ç†æ¨¡å¼?- è®ºæ–‡ç¬?èŠ?
        processing_options = self.evaluator.evaluate_all_modes(
            task, candidate_nodes, node_states, node_positions, cache_states
        )
        
        # 4. é€‰æ‹©æœ€ä½³é€‰é¡¹
        best_option = self.evaluator.select_best_option(processing_options)
        
        # 5. æ›´æ–°ç»Ÿè®¡
        if best_option:
            self.decision_stats[best_option.mode] += 1
        self.total_decisions += 1
        
        return best_option
    
    def get_decision_statistics(self) -> Dict:
        """è·å–å†³ç­–ç»Ÿè®¡ä¿¡æ¯"""
        if self.total_decisions == 0:
            return {mode.value: 0.0 for mode in ProcessingMode}
        
        stats = {}
        for mode, count in self.decision_stats.items():
            stats[mode.value] = count / self.total_decisions
        
        # æ·»åŠ åˆ†ç±»ç»Ÿè®¡
        stats['classification_distribution'] = self.classifier.get_classification_distribution()
        stats['total_decisions'] = self.total_decisions
        
        return stats
