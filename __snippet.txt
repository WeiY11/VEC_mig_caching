@dataclass
class ProcessingOption:
    """å¤„ç†é€‰é¡¹æ•°æ®ç»“æ„"""
    mode: ProcessingMode
    target_node_id: str
    predicted_delay: float
    energy_cost: float
    success_probability: float
    migration_source: Optional[str] = None  # è¿ç§»æºèŠ‚ç‚?(ä»…è¿ç§»æ¨¡å¼?
    cache_hit: bool = False  # æ˜¯å¦ç¼“å­˜å‘½ä¸­
    
    @property
    def weighted_cost(self) -> float:
        """è®¡ç®—åŠ æƒæˆæœ¬"""
        # å½’ä¸€åŒ–å› å­?- åŸºäºå®é™…æ•°æ®èŒƒå›´è°ƒæ•´
        delay_norm = 0.15  # ç§?(åŸºäºå¹³å‡æ—¶å»¶0.08ç§?
        energy_norm = 250.0  # ç„¦è€?(åŸºäºå¹³å‡èƒ½è€?00Wå·¦å³)
        
        # æƒé‡ (å¯é…ç½? - è¿›ä¸€æ­¥å¢åŠ èƒ½è€—æƒé‡ä»¥ä¿ƒè¿›å¸è½½
        w_delay = 0.15  # è¿›ä¸€æ­¥é™ä½æ—¶å»¶æƒé‡?
        w_energy = 0.7  # è¿›ä¸€æ­¥å¢åŠ èƒ½è€—æƒé‡?
        w_reliability = 0.15  # è¿›ä¸€æ­¥é™ä½å¯é æ€§æƒé‡?
        
        normalized_delay = self.predicted_delay / delay_norm
        normalized_energy = self.energy_cost / energy_norm
        reliability_penalty = 1.0 - self.success_probability
        
        return (w_delay * normalized_delay + 
                w_energy * normalized_energy + 
                w_reliability * reliability_penalty)


